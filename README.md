# PizzaStore

- First, we create variables to count the number of available employees, the successful and failed orders, the number of different pizza types that have been purchased, as well as the total revenue. Then, we create mutexes and condition variables to prevent threads from modifying the global variables simultaneously, which could lead to problems. In addition to these, there are variables for the total service time, the maximum service time, the total cooling time, and the maximum cooling time.

- In the main function, we initialize the mutexes using the pthread_mutex_init command and then create the customer threads with pthread_create, calling the customer_routine function to start the service process. We use the function sleep(rand_r(&seed) % time_orderhigh + 1) to simulate the waiting time between the arrivals of consecutive customers. In case the customer thread cannot be created, we print an appropriate error message.

- In customer_routine, we use while loops to check whether certain conditions are violated (e.g., no available operators), and if so, we temporarily block the corresponding order from proceeding further. Every time we access or modify a shared (global) variable, we use the pthread libraryâ€™s lock and unlock commands to prevent multiple threads from accessing it simultaneously, which could lead to incorrect results. When a variable is released, we send a signal using the corresponding condition variable (pthread_cond_signal), allowing another thread to gain access to it. In this way, we achieve multithreaded execution of the program, which results in faster overall performance. Finally, considering the possibility of a payment failure, we print an appropriate message to the user.